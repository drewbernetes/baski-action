name: 'Build and Scan Kubernetes Images Action'
author: "Drew Hudson-Viles"
branding:
  icon: layers
  color: blue
description: |
  A composite Action for remotely building an image using
  the [kubernetes-image-builder](https://github.com/kubernetes-sigs/image-builder) repo.
  It uses [Baski](https://github.com/drewbernetes/baski) under the hood to build the images and scan them.

  When the baski configuration changes, there will be a new release of the action to coincide, otherwise the action will remain compatible.

  # Scope

  ⚠️Currently in beta at the moment.

  # Prerequisites
  * [Openstack]()./docs/openstack.md


  # TODO
  * Probably loads, but this will do for now!

  # License
  The scripts and documentation in this project are released under the [Apache v2 License](LICENSE).
inputs:
  task-type:
    description: "Comma delimited list of Baski tasks to run. build, scan or sign are valid options - you can also use 'all' to signal all of the tasks."
    default: "all"
  # Infra config
  infra-type:
    description: "openstack is currently supported, kubevirt is in progress"
    default: "openstack"
    required: true
  # OpenStack Credentials
  openstack-auth-url:
    description: "The authentication endpoint of OpenStack to send requests to."
  openstack-username:
    description: "The username to authenticate with - required if not using application credentials."
  openstack-password:
    description: "The password to authenticate with - required if not using application credentials."
  openstack-application-credential-id:
    description: "The application credential id to authenticate with - required if not using username/password combination."
  openstack-application-credential-secret:
    description: "The application credential secret to authenticate with - required if not using username/password combination."
  openstack-project-name:
    description: "The name of the Openstack project."
  openstack-project-id:
    description: "The ID of the Openstack project."
  openstack-user-domain-name:
    description: "The name of the UserDomainName."
    default: "Default"
  openstack-region:
    description: "The name of the region to deploy to."
    default: "RegionOne"
  openstack-identity-api-version:
    description: "The Identity API Version for OpenStack."
    default: "3"
  openstack-interface:
    description: "The name of the interface."
    default: "public"
  # OpenStack Config
  openstack-network-id:
    description: "The ID of the network to use to use to build the scanning system."
  openstack-source-image-id:
    description: "The ID of the source image to use for the image build."
  openstack-flavor-name:
    description: "The OpenStack instance flavor to use to build the image."
  openstack-attach-config-drive:
    description: "Whether to enable to config drive in OpenStack. Useful if building an instance with an external IP attached."
    default: "false"
  openstack-use-floating-ip:
    description: "Enable to use floating IPs on the build instance."
    default: "true"
  openstack-floating-ip-network-name:
    description: "If using a floating IP configuration, add the network name here to which the floating IP will be acquired from. (Usually the provider network)."
    default: "Internet"
  openstack-security-group:
    description: "The security group in OpenStack to assign to the VM that will build the image - requires SSH access."
    default: "default"
  openstack-image-visibility:
    description: "Set the image visibility once it has been created. Usually required admin permissions of sorts. Ensure you have this before setting this as the whole process will fail if permissions are not set."
    default: "private"
  openstack-image-disk-format:
    description: "The format of the image on OpenStack. Your openstack instance must support this."
    default: "raw"
  openstack-use-blockstorage-volume:
    description: "Sets the parameter block_storage_volume in the OpenStack Packer config."
    default: "false"
  openstack-ssh-keypair-name:
    description: "Use an existing SSH KeyPair from OpenStack - one will be autogenerated if not set."
  openstack-ssh-privatekey-file:
    description: "If using a ssh-keypair-name, a private key is required. In an automation environment, this is not recommended due to the potential exposure of a key."
  openstack-volume-type:
    description: "The volume type to use in OpenStack."
    default: ""
  openstack-volume-size:
    description: "The size of the storage volume in OpenStack."
    default: ""
  openstack-metadata-prefix:
    description: "Metadata-prefix will be used to prefix any metadata. This can be left blank if not required but if your metadata requires a prefix like `baski:k8s-version`, this is the place to add it."
  # KubeVirt - currently not supported by the action
  #  kubevirt-qemu-binary:
  #    description: "qemu_binary enables the overriding of the qemu-system-x86_64 binary name"
  #    default: "qemu-system-x86_64"
  #  kubevirt-disk-size:
  #    description: "Describes the size of the VM disk"
  #    default: "10G"
  #  kubevirt-output-directory:
  #    description: "The directory in which the resulting QCOW2 image will be stored."
  #  kubevirt-store-in-s3:
  #    description: "This enables the image to be uploaded to an S3 endpoint as defined in S3 variables"
  #  kubevirt-image-bucket:
  #    description: "The bucket in which to store the resulting image (required if S3 is used)"
  #  kubevirt-image-namespace:
  #    description: "The namespace in which the DV will be created"
  # K8S
  k8s-kubeconfig-path:
    description: "Path to the kubeconfig that will be used to generate the PVC for Kubevirt"
  # S3
  s3-endpoint:
    description: "The endpoint of S3."
  s3-access:
    description: "The access key used to access S3s."
  s3-secret:
    description: "The secret key used to access S3."
  s3-region:
    description: "The S3 region."
    default: "us-east-1"
  s3-is-ceph:
    description: "If the S3 endpoint is ceph based, for example behind OpenStack, this should be set to true."
  # Build
  build-verbose:
    description: "Enables verbose mode."
    default: "false"
  build-os:
    description: "The OS to build. Currently supports ubuntu-2204 and ubuntu-2404."
    default: "ubuntu-2204"
  build-image-prefix:
    description: "The prefix to apply to the image name."
  build-image-builder-repo:
    description: "The to use for building Kubernetes images."
    default: "https://github.com/kubernetes-sigs/image-builder.git"
  build-image-builder-repo-branch:
    description: "The branch to use fir iamge builds."
    default: "main"
  build-containerd-version:
    description: 'The containerd version to deploy into the image.'
    default: "1.7.21"
  build-containerd-sha256:
    description: 'The sha256 of containerd.'
    default: "3d1fcdfd0b141f4dc4916b7aee7f9a7773dc344baffc8954e1ca66b1adc5c120"
  build-crictl-version:
    description: 'The crictl version to deploy into the image.'
    default: "1.30.1"
  build-cni-version:
    description: 'The CNI version to deploy into the image.'
    default: "1.2.0"
  build-cni-deb-version:
    description: 'The CNI .DEB version to deploy into the image.'
    default: "1.4.0-2.1"
  build-k8s-version:
    description: 'The Kubernetes version to deploy into the image.'
    default: "1.30.4"
  build-k8s-deb-version:
    description: 'The Kubernetes .DEB version to deploy into the image.'
    default: "1.30.4-1.1"
  build-extra-debs:
    description: 'A space-separated list of any additional (Debian / Ubuntu) packages to install.'
  build-add-trivy:
    description: 'Install Trivy into the image.'
    default: "false"
  build-add-falco:
    description: 'Install Falco into the image.'
    default: "false"
  build-additional-images:
    description: "A comma delimited list of container images that should be added to the final image."
  build-additional-metadata:
    description: "A comma delimited list of metadata that should be added to the image."
  # GPU
  build-enable-gpu-support:
    description: "Enable the installation of GPU drivers - requires additional settings."
    default: "false"
  build-gpu-vendor:
    description: "Set the GPU vendor to install the correct drivers. AMD/NVIDIA."
  build-gpu-model-support:
    description: "The specified GPU model is added to the metadata of the image."
  build-gpu-instance-support:
    description: "The specified instance type is added to the image metadata."
  build-amd-driver-version:
    description: "The AMD driver version to install."
  build-amd-driver-deb-version:
    description: "The AMD .DEB version of the driver to install."
  build-amd-usecase:
    description: "dkms"
  build-nvidia-driver-version:
    description: "The NVIDIA Driver version you are installing. This is currently only used to set the image name."
  build-nvidia-bucket:
    description: "The bucket name that the NVIDIA components are downloaded from."
  build-nvidia-installer-location:
    description: "The NVIDIA installer location in the bucket - this must be acquired from NVIDIA and uploaded to your bucket."
  build-nvidia-tok-location:
    description: "The NVIDIA .tok file location in the bucket - this must be acquired from NVIDIA and uploaded to your bucket."
  build-nvidia-gridd-feature-type:
    description: "The gridd feature type - See https://docs.nvidia.com/license-system/latest/nvidia-license-system-quick-start-guide/index.html#configuring-nls-licensed-client-on-linux for more information."
    default: "4"
  # Scan
  scan-type:
    description: "Define the scan type. single or multiple"
    default: "single"
  scan-single-image-id:
    description: "If scanning a single image, enter the Id of it here."
  scan-multiple-image-search:
    description: "The search prefix to locate images."
    default: "kmi-"
  scan-multiple-concurrency:
    description: "How many concurrent scans to run."
    default: "2"
  scan-flavor-name:
    description: "The instance flavor to use to scan the image."
  scan-auto-delete-image:
    description: "Whether to delete the image should a CVE check fail."
    default: "false"
  scan-skip-cve-check:
    description: "Whether to run a CVE check after the scan runs. This will cause a pipeline to fail if a vulnerability is found and meets the threshold defined in the two options below."
    default: "false"
  scan-min-severity-type:
    description: "The type of CVE Severity to check for. NONE, LOW, MEDIUM, HIGH and CRITICAL are supported. The value entered here is the minimum it will check for along with anything higher."
    default: "MEDIUM"
  scan-bucket:
    description: "The bucket used to locate a trivyignore file."
  scan-trivyignore-path:
    description: "The path in the bucket where the trivyignore file is located."
  scan-trivyignore-filename:
    description: "The name of the trivyignore file in the bucket."
    default: "trivyignore"
  scan-trivyignore-list:
    description: "A comma delimited list of CVEs to ignore. This will be appended to the trivyignore file from the scan bucket if one is provided."
  sign-vault-url:
    description: "The endpoint address of vault from which the keys will be pulled for signing the image."
    default: ""
  sign-vault-token:
    description: "The token for accessing vault."
    default: ""
  sign-vault-mount-path:
    description: "The mount path in vault which contains the secret with the signing key."
    default: ""
  sign-vault-secret-name:
    description: "The name of the secret in the mount path that contains the signing key."
    default: ""
  sign-image-id:
    description: "The ID of the image to sign."
    default: ""
runs:
  using: "composite"
  steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: "Setup the clouds.yaml file"
      id: prepare_cloud
      shell: bash
      run: ${{github.action_path}}/scripts/determine-infra-type.sh
      env:
        INFRA_TYPE: "${{ inputs.infra-type }}"
        OS_URL: "${{ inputs.openstack-auth-url }}"
        OS_USER: "${{ inputs.openstack-username }}"
        OS_PASSWD: "${{ inputs.openstack-password }}"
        OS_APP_ID: "${{ inputs.openstack-application-credential-id }}"
        OS_APP_SECRET: "${{ inputs.openstack-application-credential-secret }}"
        OS_REGION: "${{ inputs.openstack-region }}"
        OS_INTERFACE: "${{ inputs.openstack-interface }}"
        OS_PROJ_ID: "${{ inputs.openstack-project-id }}"
        OS_PROJ_NAME: "${{ inputs.openstack-project-name }}"
        OS_USR_DOM: "${{ inputs.openstack-user-domain-name }}"
        OS_API: "${{ inputs.openstack-identity-api-version }}"

    - name: "Fetch Baski"
      if: runner.os == 'Linux'
      id: fetch_baski
      env:
        BASKI_VERSION: "v1.2.2"
      shell: bash
      run: ${{github.action_path}}/scripts/baski.sh update


    - name: "Build Image"
      if: ${{ runner.os == 'Linux' && (inputs.task-type == 'all' || inputs.task-type == 'build') }}
      id: build
      shell: bash
      run: ${{github.action_path}}/scripts/baski.sh build
      env:
        INFRA_TYPE: "${{ inputs.infra-type }}"
        S3_ENDPOINT: "${{ inputs.s3-endpoint }}"
        S3_ACCESS: "${{ inputs.s3-access }}"
        S3_SECRET: "${{ inputs.s3-secret }}"
        S3_REGION: "${{ inputs.s3-region }}"
        S3_IS_CEPH: "${{ inputs.s3-is-ceph }}"
        OS_NET_ID: "${{ inputs.openstack-network-id }}"
        OS_CONF_DRIVE: "${{ inputs.openstack-attach-config-drive }}"
        OS_FIP_NET: "${{ inputs.openstack-floating-ip-network-name }}"
        OS_SECURITY_GROUP: "${{ inputs.openstack-security-group }}"
        OS_FLAVOR: "${{ inputs.openstack-flavor-name }}"
        OS_SOURCE_IMAGE: "${{ inputs.openstack-source-image-id }}"
        OS_USE_FIP: "${{ inputs.openstack-use-floating-ip }}"
        OS_VISIBILITY: "${{ inputs.openstack-image-visibility }}"
        OS_DISK_FORMAT: "${{ inputs.openstack-image-disk-format }}"
        OS_VOL_TYPE: "${{ inputs.openstack-volume-type }}"
        OS_VOL_SIZE: "${{ inputs.openstack-volume-size }}"
        OS_USE_BLOCK: "${{ inputs.openstack-use-blockstorage-volume }}"
        OS_META_PREFIX: "${{ inputs.openstack-metadata-prefix }}"
        BUILD_VERBOSE: "${{ inputs.build-verbose }}"
        BUILD_OS: "${{ inputs.build-os }}"
        BUILD_PREFIX: "${{ inputs.build-image-prefix }}"
        BUILD_REPO: "${{ inputs.build-image-builder-repo }}"
        BUILD_REPO_BRANCH: "${{ inputs.build-image-builder-repo-branch }}"
        BUILD_CONTAINERD_VERS: "${{ inputs.build-containerd-version }}"
        BUILD_CONTAINERD_SHA256: "${{ inputs.build-containerd-sha256 }}"
        BUILD_CRI_VERS: "${{ inputs.build-crictl-version }}"
        BUILD_CNI_VERS: "${{ inputs.build-cni-version }}"
        BUILD_CNI_DEB_VERS: "${{ inputs.build-cni-deb-version }}"
        BUILD_K8S_VERS: "${{ inputs.build-k8s-version }}"
        BUILD_K8S_DEB_VERS: "${{ inputs.build-k8s-deb-version }}"
        BUILD_EXTRA_DEBS: "${{ inputs.build-extra-debs }}"
        BUILD_TRIVY: "${{ inputs.build-add-trivy }}"
        BUILD_FALCO: "${{ inputs.build-add-falco }}"
        BUILD_ADDITIONAL_IMAGES: "${{ inputs.build-additional-images }}"
        BUILD_ADDITIONAL_META: "${{ inputs.build-additional-metadata }}"
        GPU_ENABLE: "${{ inputs.build-enable-gpu-support }}"
        GPU_VENDOR: "${{ inputs.build-gpu-vendor }}"
        GPU_MODEL: "${{ inputs.build-gpu-model-support }}"
        GPU_INSTANCE: "${{ inputs.build-gpu-instance-support }}"
        GPU_AMD_DRIVER_VERS: "${{ inputs.build-amd-driver-version }}"
        GPU_AMD_DRIVER_DEB_VERS: "${{ inputs.build-amd-driver-deb-version }}"
        GPU_AMD_USECASE: "${{ inputs.build-amd-usecase }}"
        GPU_NVIDIA_DRIVER_VERS: "${{ inputs.build-nvidia-driver-version }}"
        GPU_NVIDIA_BUCKET: "${{ inputs.build-nvidia-bucket }}"
        GPU_NVIDIA_INSTALLER: "${{ inputs.build-nvidia-installer-location }}"
        GPU_NVIDIA_TOK: "${{ inputs.build-nvidia-tok-location }}"
        GPU_NVIDIA_GRIDD: "${{ inputs.build-nvidia-gridd-feature-type }}"

    - name: "Get image ID for scanning"
      if: ${{ runner.os == 'Linux' && (inputs.task-type == 'all' || inputs.task-type == 'scan') }}
      id: scan-img
      shell: bash
      run: |
        declare IMG_ID 
        if [[ ${{ inputs.task-type }} == *"build"* ]] || [[ ${{ inputs.task-type }} == "all" ]]; then
          # If the task-type contains build or is all, then it should have an outputted ID from the build step.
          IMG_ID="${{ steps.build.outputs.new-image-id }}"
        elif [[ ${{ inputs.task-type }} != *"build"* ]] && [[ ${{ inputs.task-type }} != "all" ]]; then
          # Else if the task is not all or does not contain the build keyword, we'll take the scan-image-id
          IMG_ID="${{ inputs.scan-single-image-id }}"
        fi
        echo "image-id=${IMG_ID}" >> $GITHUB_OUTPUT

    - name: "Scan Image"
      if: ${{ runner.os == 'Linux' && (inputs.task-type == 'all' || inputs.task-type == 'scan') }}
      id: scan
      shell: bash
      run: ${{github.action_path}}/scripts/baski.sh scan
      env:
        INFRA_TYPE: "${{ inputs.infra-type }}"
        OS_NET_ID: "${{ inputs.openstack-network-id }}"
        OS_CONF_DRIVE: "${{ inputs.openstack-attach-config-drive }}"
        OS_FIP_NET: "${{ inputs.openstack-floating-ip-network-name }}"
        OS_SECURITY_GROUP: "${{ inputs.openstack-security-group }}"
        OS_META_PREFIX: "${{ inputs.openstack-metadata-prefix }}"
        OS_FLAVOR: "${{ inputs.openstack-flavor-name }}"
        S3_ENDPOINT: "${{ inputs.s3-endpoint }}"
        S3_ACCESS: "${{ inputs.s3-access }}"
        S3_SECRET: "${{ inputs.s3-secret }}"
        S3_REGION: "${{ inputs.s3-region }}"
        S3_IS_CEPH: "${{ inputs.s3-is-ceph }}"
        SCAN_TYPE: "${{ inputs.scan-type }}"
        SCAN_SINGLE_IMG_ID: "${{ steps.scan-img.outputs.image-id }}"
        SCAN_MULTI_PREFIX: "${{ inputs.scan-multiple-image-search }}"
        SCAN_MULTI_CONCURRENCY: "${{ inputs.scan-multiple-concurrency }}"
        SCAN_FLAVOR: "${{ inputs.scan-flavor-name }}"
        SCAN_AUTO_DELETE: "${{ inputs.scan-auto-delete-image }}"
        SCAN_SKIP_CVE: "${{ inputs.scan-skip-cve-check }}"
        SCAN_SEV: "${{ inputs.scan-min-severity-type }}"
        SCAN_BUCKET: "${{ inputs.scan-bucket }}"
        SCAN_TRIVY_PATH: "${{ inputs.scan-trivyignore-path }}"
        SCAN_TRIVY_FILE: "${{ inputs.scan-trivyignore-filename}}"
        SCAN_TRIVY_LIST: "${{ inputs.scan-trivyignore-list }}"

    # Upload the SBOM scan results
    - name: "Upload required fixes results upon scan fail"
      uses: actions/upload-artifact@v4
      if: (success() || failure()) && (steps.scan.conclusion == 'success' || steps.scan.outcome == 'failure')
      with:
        name: "results.json"
        path: "/tmp/${{ steps.scan-img.outputs.image-id }}.json"

    - name: "Get image ID for signing"
      if: ${{ runner.os == 'Linux' && (inputs.task-type == 'all' || inputs.task-type == 'sign') }}
      id: sign-img
      shell: bash
      run: |
        declare IMG_ID
        if [[ ${{ inputs.task-type }} == *"build"* ]] || [[ ${{ inputs.task-type }} == "all" ]]; then
        # If the task-type contains build or is all, then it should have an outputted ID from the build step.
          IMG_ID="${{ steps.build.outputs.new-image-id }}"
        elif [[ ${{ inputs.task-type }} != *"build"* ]] && [[ ${{ inputs.task-type }} != "all" ]]; then
        # Else if the task is not all or does not contain the build keyword, we'll take the sign-image-id
          IMG_ID="${{ inputs.sign-image-id }}"
        fi
        echo "image-id=${IMG_ID}" >> $GITHUB_OUTPUT

    - name: "Sign Image"
      if: ${{ runner.os == 'Linux' && (inputs.task-type == 'all' || inputs.task-type == 'sign') }}
      id: sign
      shell: bash
      run: ${{github.action_path}}/scripts/baski.sh sign image
      env:
        INFRA_TYPE: "${{ inputs.infra-type }}"
        SIGN_VAULT_URL: "${{ inputs.sign-vault-url }}"
        SIGN_VAULT_TOKEN: "${{ inputs.sign-vault-token }}"
        SIGN_VAULT_MOUNT: "${{ inputs.sign-vault-mount-path }}"
        SIGN_VAULT_SECRET: "${{ inputs.sign-vault-secret-name }}"
        SIGN_IMG_ID: "${{ steps.sign-img.outputs.image-id }}"